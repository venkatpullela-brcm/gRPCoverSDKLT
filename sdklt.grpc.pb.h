// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: sdklt.proto
#ifndef GRPC_sdklt_2eproto__INCLUDED
#define GRPC_sdklt_2eproto__INCLUDED

#include "sdklt.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace sdklt {

class Api final {
 public:
  static constexpr char const* service_full_name() {
    return "sdklt.Api";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status bcmInit(::grpc::ClientContext* context, const ::sdklt::InitRequest& request, ::sdklt::InitState* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sdklt::InitState>> AsyncbcmInit(::grpc::ClientContext* context, const ::sdklt::InitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sdklt::InitState>>(AsyncbcmInitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sdklt::InitState>> PrepareAsyncbcmInit(::grpc::ClientContext* context, const ::sdklt::InitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sdklt::InitState>>(PrepareAsyncbcmInitRaw(context, request, cq));
    }
    virtual ::grpc::Status bcmShell(::grpc::ClientContext* context, const ::sdklt::ShellRequest& request, ::sdklt::ShellState* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sdklt::ShellState>> AsyncbcmShell(::grpc::ClientContext* context, const ::sdklt::ShellRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sdklt::ShellState>>(AsyncbcmShellRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sdklt::ShellState>> PrepareAsyncbcmShell(::grpc::ClientContext* context, const ::sdklt::ShellRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sdklt::ShellState>>(PrepareAsyncbcmShellRaw(context, request, cq));
    }
    virtual ::grpc::Status bcmShutdown(::grpc::ClientContext* context, const ::sdklt::ShutDownRequest& request, ::sdklt::ShutDownState* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sdklt::ShutDownState>> AsyncbcmShutdown(::grpc::ClientContext* context, const ::sdklt::ShutDownRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sdklt::ShutDownState>>(AsyncbcmShutdownRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sdklt::ShutDownState>> PrepareAsyncbcmShutdown(::grpc::ClientContext* context, const ::sdklt::ShutDownRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sdklt::ShutDownState>>(PrepareAsyncbcmShutdownRaw(context, request, cq));
    }
    // Write the table based on
    virtual ::grpc::Status openWrite(::grpc::ClientContext* context, const ::sdklt::WriteRequest& request, ::sdklt::WriteResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sdklt::WriteResponse>> AsyncopenWrite(::grpc::ClientContext* context, const ::sdklt::WriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sdklt::WriteResponse>>(AsyncopenWriteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sdklt::WriteResponse>> PrepareAsyncopenWrite(::grpc::ClientContext* context, const ::sdklt::WriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sdklt::WriteResponse>>(PrepareAsyncopenWriteRaw(context, request, cq));
    }
    virtual ::grpc::Status openRead(::grpc::ClientContext* context, const ::sdklt::ReadRequest& request, ::sdklt::ReadResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sdklt::ReadResponse>> AsyncopenRead(::grpc::ClientContext* context, const ::sdklt::ReadRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sdklt::ReadResponse>>(AsyncopenReadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sdklt::ReadResponse>> PrepareAsyncopenRead(::grpc::ClientContext* context, const ::sdklt::ReadRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sdklt::ReadResponse>>(PrepareAsyncopenReadRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void bcmInit(::grpc::ClientContext* context, const ::sdklt::InitRequest* request, ::sdklt::InitState* response, std::function<void(::grpc::Status)>) = 0;
      virtual void bcmInit(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sdklt::InitState* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void bcmInit(::grpc::ClientContext* context, const ::sdklt::InitRequest* request, ::sdklt::InitState* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void bcmInit(::grpc::ClientContext* context, const ::sdklt::InitRequest* request, ::sdklt::InitState* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void bcmInit(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sdklt::InitState* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void bcmInit(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sdklt::InitState* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void bcmShell(::grpc::ClientContext* context, const ::sdklt::ShellRequest* request, ::sdklt::ShellState* response, std::function<void(::grpc::Status)>) = 0;
      virtual void bcmShell(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sdklt::ShellState* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void bcmShell(::grpc::ClientContext* context, const ::sdklt::ShellRequest* request, ::sdklt::ShellState* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void bcmShell(::grpc::ClientContext* context, const ::sdklt::ShellRequest* request, ::sdklt::ShellState* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void bcmShell(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sdklt::ShellState* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void bcmShell(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sdklt::ShellState* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void bcmShutdown(::grpc::ClientContext* context, const ::sdklt::ShutDownRequest* request, ::sdklt::ShutDownState* response, std::function<void(::grpc::Status)>) = 0;
      virtual void bcmShutdown(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sdklt::ShutDownState* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void bcmShutdown(::grpc::ClientContext* context, const ::sdklt::ShutDownRequest* request, ::sdklt::ShutDownState* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void bcmShutdown(::grpc::ClientContext* context, const ::sdklt::ShutDownRequest* request, ::sdklt::ShutDownState* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void bcmShutdown(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sdklt::ShutDownState* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void bcmShutdown(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sdklt::ShutDownState* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Write the table based on
      virtual void openWrite(::grpc::ClientContext* context, const ::sdklt::WriteRequest* request, ::sdklt::WriteResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void openWrite(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sdklt::WriteResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void openWrite(::grpc::ClientContext* context, const ::sdklt::WriteRequest* request, ::sdklt::WriteResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void openWrite(::grpc::ClientContext* context, const ::sdklt::WriteRequest* request, ::sdklt::WriteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void openWrite(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sdklt::WriteResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void openWrite(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sdklt::WriteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void openRead(::grpc::ClientContext* context, const ::sdklt::ReadRequest* request, ::sdklt::ReadResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void openRead(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sdklt::ReadResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void openRead(::grpc::ClientContext* context, const ::sdklt::ReadRequest* request, ::sdklt::ReadResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void openRead(::grpc::ClientContext* context, const ::sdklt::ReadRequest* request, ::sdklt::ReadResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void openRead(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sdklt::ReadResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void openRead(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sdklt::ReadResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sdklt::InitState>* AsyncbcmInitRaw(::grpc::ClientContext* context, const ::sdklt::InitRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sdklt::InitState>* PrepareAsyncbcmInitRaw(::grpc::ClientContext* context, const ::sdklt::InitRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sdklt::ShellState>* AsyncbcmShellRaw(::grpc::ClientContext* context, const ::sdklt::ShellRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sdklt::ShellState>* PrepareAsyncbcmShellRaw(::grpc::ClientContext* context, const ::sdklt::ShellRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sdklt::ShutDownState>* AsyncbcmShutdownRaw(::grpc::ClientContext* context, const ::sdklt::ShutDownRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sdklt::ShutDownState>* PrepareAsyncbcmShutdownRaw(::grpc::ClientContext* context, const ::sdklt::ShutDownRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sdklt::WriteResponse>* AsyncopenWriteRaw(::grpc::ClientContext* context, const ::sdklt::WriteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sdklt::WriteResponse>* PrepareAsyncopenWriteRaw(::grpc::ClientContext* context, const ::sdklt::WriteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sdklt::ReadResponse>* AsyncopenReadRaw(::grpc::ClientContext* context, const ::sdklt::ReadRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sdklt::ReadResponse>* PrepareAsyncopenReadRaw(::grpc::ClientContext* context, const ::sdklt::ReadRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status bcmInit(::grpc::ClientContext* context, const ::sdklt::InitRequest& request, ::sdklt::InitState* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sdklt::InitState>> AsyncbcmInit(::grpc::ClientContext* context, const ::sdklt::InitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sdklt::InitState>>(AsyncbcmInitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sdklt::InitState>> PrepareAsyncbcmInit(::grpc::ClientContext* context, const ::sdklt::InitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sdklt::InitState>>(PrepareAsyncbcmInitRaw(context, request, cq));
    }
    ::grpc::Status bcmShell(::grpc::ClientContext* context, const ::sdklt::ShellRequest& request, ::sdklt::ShellState* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sdklt::ShellState>> AsyncbcmShell(::grpc::ClientContext* context, const ::sdklt::ShellRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sdklt::ShellState>>(AsyncbcmShellRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sdklt::ShellState>> PrepareAsyncbcmShell(::grpc::ClientContext* context, const ::sdklt::ShellRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sdklt::ShellState>>(PrepareAsyncbcmShellRaw(context, request, cq));
    }
    ::grpc::Status bcmShutdown(::grpc::ClientContext* context, const ::sdklt::ShutDownRequest& request, ::sdklt::ShutDownState* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sdklt::ShutDownState>> AsyncbcmShutdown(::grpc::ClientContext* context, const ::sdklt::ShutDownRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sdklt::ShutDownState>>(AsyncbcmShutdownRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sdklt::ShutDownState>> PrepareAsyncbcmShutdown(::grpc::ClientContext* context, const ::sdklt::ShutDownRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sdklt::ShutDownState>>(PrepareAsyncbcmShutdownRaw(context, request, cq));
    }
    ::grpc::Status openWrite(::grpc::ClientContext* context, const ::sdklt::WriteRequest& request, ::sdklt::WriteResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sdklt::WriteResponse>> AsyncopenWrite(::grpc::ClientContext* context, const ::sdklt::WriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sdklt::WriteResponse>>(AsyncopenWriteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sdklt::WriteResponse>> PrepareAsyncopenWrite(::grpc::ClientContext* context, const ::sdklt::WriteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sdklt::WriteResponse>>(PrepareAsyncopenWriteRaw(context, request, cq));
    }
    ::grpc::Status openRead(::grpc::ClientContext* context, const ::sdklt::ReadRequest& request, ::sdklt::ReadResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sdklt::ReadResponse>> AsyncopenRead(::grpc::ClientContext* context, const ::sdklt::ReadRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sdklt::ReadResponse>>(AsyncopenReadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sdklt::ReadResponse>> PrepareAsyncopenRead(::grpc::ClientContext* context, const ::sdklt::ReadRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sdklt::ReadResponse>>(PrepareAsyncopenReadRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void bcmInit(::grpc::ClientContext* context, const ::sdklt::InitRequest* request, ::sdklt::InitState* response, std::function<void(::grpc::Status)>) override;
      void bcmInit(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sdklt::InitState* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void bcmInit(::grpc::ClientContext* context, const ::sdklt::InitRequest* request, ::sdklt::InitState* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void bcmInit(::grpc::ClientContext* context, const ::sdklt::InitRequest* request, ::sdklt::InitState* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void bcmInit(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sdklt::InitState* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void bcmInit(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sdklt::InitState* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void bcmShell(::grpc::ClientContext* context, const ::sdklt::ShellRequest* request, ::sdklt::ShellState* response, std::function<void(::grpc::Status)>) override;
      void bcmShell(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sdklt::ShellState* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void bcmShell(::grpc::ClientContext* context, const ::sdklt::ShellRequest* request, ::sdklt::ShellState* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void bcmShell(::grpc::ClientContext* context, const ::sdklt::ShellRequest* request, ::sdklt::ShellState* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void bcmShell(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sdklt::ShellState* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void bcmShell(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sdklt::ShellState* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void bcmShutdown(::grpc::ClientContext* context, const ::sdklt::ShutDownRequest* request, ::sdklt::ShutDownState* response, std::function<void(::grpc::Status)>) override;
      void bcmShutdown(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sdklt::ShutDownState* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void bcmShutdown(::grpc::ClientContext* context, const ::sdklt::ShutDownRequest* request, ::sdklt::ShutDownState* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void bcmShutdown(::grpc::ClientContext* context, const ::sdklt::ShutDownRequest* request, ::sdklt::ShutDownState* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void bcmShutdown(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sdklt::ShutDownState* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void bcmShutdown(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sdklt::ShutDownState* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void openWrite(::grpc::ClientContext* context, const ::sdklt::WriteRequest* request, ::sdklt::WriteResponse* response, std::function<void(::grpc::Status)>) override;
      void openWrite(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sdklt::WriteResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void openWrite(::grpc::ClientContext* context, const ::sdklt::WriteRequest* request, ::sdklt::WriteResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void openWrite(::grpc::ClientContext* context, const ::sdklt::WriteRequest* request, ::sdklt::WriteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void openWrite(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sdklt::WriteResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void openWrite(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sdklt::WriteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void openRead(::grpc::ClientContext* context, const ::sdklt::ReadRequest* request, ::sdklt::ReadResponse* response, std::function<void(::grpc::Status)>) override;
      void openRead(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sdklt::ReadResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void openRead(::grpc::ClientContext* context, const ::sdklt::ReadRequest* request, ::sdklt::ReadResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void openRead(::grpc::ClientContext* context, const ::sdklt::ReadRequest* request, ::sdklt::ReadResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void openRead(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sdklt::ReadResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void openRead(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::sdklt::ReadResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::sdklt::InitState>* AsyncbcmInitRaw(::grpc::ClientContext* context, const ::sdklt::InitRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sdklt::InitState>* PrepareAsyncbcmInitRaw(::grpc::ClientContext* context, const ::sdklt::InitRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sdklt::ShellState>* AsyncbcmShellRaw(::grpc::ClientContext* context, const ::sdklt::ShellRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sdklt::ShellState>* PrepareAsyncbcmShellRaw(::grpc::ClientContext* context, const ::sdklt::ShellRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sdklt::ShutDownState>* AsyncbcmShutdownRaw(::grpc::ClientContext* context, const ::sdklt::ShutDownRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sdklt::ShutDownState>* PrepareAsyncbcmShutdownRaw(::grpc::ClientContext* context, const ::sdklt::ShutDownRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sdklt::WriteResponse>* AsyncopenWriteRaw(::grpc::ClientContext* context, const ::sdklt::WriteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sdklt::WriteResponse>* PrepareAsyncopenWriteRaw(::grpc::ClientContext* context, const ::sdklt::WriteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sdklt::ReadResponse>* AsyncopenReadRaw(::grpc::ClientContext* context, const ::sdklt::ReadRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sdklt::ReadResponse>* PrepareAsyncopenReadRaw(::grpc::ClientContext* context, const ::sdklt::ReadRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_bcmInit_;
    const ::grpc::internal::RpcMethod rpcmethod_bcmShell_;
    const ::grpc::internal::RpcMethod rpcmethod_bcmShutdown_;
    const ::grpc::internal::RpcMethod rpcmethod_openWrite_;
    const ::grpc::internal::RpcMethod rpcmethod_openRead_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status bcmInit(::grpc::ServerContext* context, const ::sdklt::InitRequest* request, ::sdklt::InitState* response);
    virtual ::grpc::Status bcmShell(::grpc::ServerContext* context, const ::sdklt::ShellRequest* request, ::sdklt::ShellState* response);
    virtual ::grpc::Status bcmShutdown(::grpc::ServerContext* context, const ::sdklt::ShutDownRequest* request, ::sdklt::ShutDownState* response);
    // Write the table based on
    virtual ::grpc::Status openWrite(::grpc::ServerContext* context, const ::sdklt::WriteRequest* request, ::sdklt::WriteResponse* response);
    virtual ::grpc::Status openRead(::grpc::ServerContext* context, const ::sdklt::ReadRequest* request, ::sdklt::ReadResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_bcmInit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_bcmInit() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_bcmInit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status bcmInit(::grpc::ServerContext* /*context*/, const ::sdklt::InitRequest* /*request*/, ::sdklt::InitState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestbcmInit(::grpc::ServerContext* context, ::sdklt::InitRequest* request, ::grpc::ServerAsyncResponseWriter< ::sdklt::InitState>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_bcmShell : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_bcmShell() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_bcmShell() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status bcmShell(::grpc::ServerContext* /*context*/, const ::sdklt::ShellRequest* /*request*/, ::sdklt::ShellState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestbcmShell(::grpc::ServerContext* context, ::sdklt::ShellRequest* request, ::grpc::ServerAsyncResponseWriter< ::sdklt::ShellState>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_bcmShutdown : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_bcmShutdown() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_bcmShutdown() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status bcmShutdown(::grpc::ServerContext* /*context*/, const ::sdklt::ShutDownRequest* /*request*/, ::sdklt::ShutDownState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestbcmShutdown(::grpc::ServerContext* context, ::sdklt::ShutDownRequest* request, ::grpc::ServerAsyncResponseWriter< ::sdklt::ShutDownState>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_openWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_openWrite() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_openWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status openWrite(::grpc::ServerContext* /*context*/, const ::sdklt::WriteRequest* /*request*/, ::sdklt::WriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestopenWrite(::grpc::ServerContext* context, ::sdklt::WriteRequest* request, ::grpc::ServerAsyncResponseWriter< ::sdklt::WriteResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_openRead : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_openRead() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_openRead() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status openRead(::grpc::ServerContext* /*context*/, const ::sdklt::ReadRequest* /*request*/, ::sdklt::ReadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestopenRead(::grpc::ServerContext* context, ::sdklt::ReadRequest* request, ::grpc::ServerAsyncResponseWriter< ::sdklt::ReadResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_bcmInit<WithAsyncMethod_bcmShell<WithAsyncMethod_bcmShutdown<WithAsyncMethod_openWrite<WithAsyncMethod_openRead<Service > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_bcmInit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_bcmInit() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::sdklt::InitRequest, ::sdklt::InitState>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::sdklt::InitRequest* request, ::sdklt::InitState* response) { return this->bcmInit(context, request, response); }));}
    void SetMessageAllocatorFor_bcmInit(
        ::grpc::experimental::MessageAllocator< ::sdklt::InitRequest, ::sdklt::InitState>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::sdklt::InitRequest, ::sdklt::InitState>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_bcmInit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status bcmInit(::grpc::ServerContext* /*context*/, const ::sdklt::InitRequest* /*request*/, ::sdklt::InitState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* bcmInit(
      ::grpc::CallbackServerContext* /*context*/, const ::sdklt::InitRequest* /*request*/, ::sdklt::InitState* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* bcmInit(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::sdklt::InitRequest* /*request*/, ::sdklt::InitState* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_bcmShell : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_bcmShell() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::sdklt::ShellRequest, ::sdklt::ShellState>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::sdklt::ShellRequest* request, ::sdklt::ShellState* response) { return this->bcmShell(context, request, response); }));}
    void SetMessageAllocatorFor_bcmShell(
        ::grpc::experimental::MessageAllocator< ::sdklt::ShellRequest, ::sdklt::ShellState>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::sdklt::ShellRequest, ::sdklt::ShellState>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_bcmShell() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status bcmShell(::grpc::ServerContext* /*context*/, const ::sdklt::ShellRequest* /*request*/, ::sdklt::ShellState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* bcmShell(
      ::grpc::CallbackServerContext* /*context*/, const ::sdklt::ShellRequest* /*request*/, ::sdklt::ShellState* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* bcmShell(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::sdklt::ShellRequest* /*request*/, ::sdklt::ShellState* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_bcmShutdown : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_bcmShutdown() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::sdklt::ShutDownRequest, ::sdklt::ShutDownState>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::sdklt::ShutDownRequest* request, ::sdklt::ShutDownState* response) { return this->bcmShutdown(context, request, response); }));}
    void SetMessageAllocatorFor_bcmShutdown(
        ::grpc::experimental::MessageAllocator< ::sdklt::ShutDownRequest, ::sdklt::ShutDownState>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::sdklt::ShutDownRequest, ::sdklt::ShutDownState>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_bcmShutdown() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status bcmShutdown(::grpc::ServerContext* /*context*/, const ::sdklt::ShutDownRequest* /*request*/, ::sdklt::ShutDownState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* bcmShutdown(
      ::grpc::CallbackServerContext* /*context*/, const ::sdklt::ShutDownRequest* /*request*/, ::sdklt::ShutDownState* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* bcmShutdown(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::sdklt::ShutDownRequest* /*request*/, ::sdklt::ShutDownState* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_openWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_openWrite() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::sdklt::WriteRequest, ::sdklt::WriteResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::sdklt::WriteRequest* request, ::sdklt::WriteResponse* response) { return this->openWrite(context, request, response); }));}
    void SetMessageAllocatorFor_openWrite(
        ::grpc::experimental::MessageAllocator< ::sdklt::WriteRequest, ::sdklt::WriteResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::sdklt::WriteRequest, ::sdklt::WriteResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_openWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status openWrite(::grpc::ServerContext* /*context*/, const ::sdklt::WriteRequest* /*request*/, ::sdklt::WriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* openWrite(
      ::grpc::CallbackServerContext* /*context*/, const ::sdklt::WriteRequest* /*request*/, ::sdklt::WriteResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* openWrite(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::sdklt::WriteRequest* /*request*/, ::sdklt::WriteResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_openRead : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_openRead() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::sdklt::ReadRequest, ::sdklt::ReadResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::sdklt::ReadRequest* request, ::sdklt::ReadResponse* response) { return this->openRead(context, request, response); }));}
    void SetMessageAllocatorFor_openRead(
        ::grpc::experimental::MessageAllocator< ::sdklt::ReadRequest, ::sdklt::ReadResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::sdklt::ReadRequest, ::sdklt::ReadResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_openRead() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status openRead(::grpc::ServerContext* /*context*/, const ::sdklt::ReadRequest* /*request*/, ::sdklt::ReadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* openRead(
      ::grpc::CallbackServerContext* /*context*/, const ::sdklt::ReadRequest* /*request*/, ::sdklt::ReadResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* openRead(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::sdklt::ReadRequest* /*request*/, ::sdklt::ReadResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_bcmInit<ExperimentalWithCallbackMethod_bcmShell<ExperimentalWithCallbackMethod_bcmShutdown<ExperimentalWithCallbackMethod_openWrite<ExperimentalWithCallbackMethod_openRead<Service > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_bcmInit<ExperimentalWithCallbackMethod_bcmShell<ExperimentalWithCallbackMethod_bcmShutdown<ExperimentalWithCallbackMethod_openWrite<ExperimentalWithCallbackMethod_openRead<Service > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_bcmInit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_bcmInit() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_bcmInit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status bcmInit(::grpc::ServerContext* /*context*/, const ::sdklt::InitRequest* /*request*/, ::sdklt::InitState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_bcmShell : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_bcmShell() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_bcmShell() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status bcmShell(::grpc::ServerContext* /*context*/, const ::sdklt::ShellRequest* /*request*/, ::sdklt::ShellState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_bcmShutdown : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_bcmShutdown() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_bcmShutdown() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status bcmShutdown(::grpc::ServerContext* /*context*/, const ::sdklt::ShutDownRequest* /*request*/, ::sdklt::ShutDownState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_openWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_openWrite() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_openWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status openWrite(::grpc::ServerContext* /*context*/, const ::sdklt::WriteRequest* /*request*/, ::sdklt::WriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_openRead : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_openRead() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_openRead() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status openRead(::grpc::ServerContext* /*context*/, const ::sdklt::ReadRequest* /*request*/, ::sdklt::ReadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_bcmInit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_bcmInit() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_bcmInit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status bcmInit(::grpc::ServerContext* /*context*/, const ::sdklt::InitRequest* /*request*/, ::sdklt::InitState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestbcmInit(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_bcmShell : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_bcmShell() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_bcmShell() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status bcmShell(::grpc::ServerContext* /*context*/, const ::sdklt::ShellRequest* /*request*/, ::sdklt::ShellState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestbcmShell(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_bcmShutdown : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_bcmShutdown() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_bcmShutdown() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status bcmShutdown(::grpc::ServerContext* /*context*/, const ::sdklt::ShutDownRequest* /*request*/, ::sdklt::ShutDownState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestbcmShutdown(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_openWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_openWrite() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_openWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status openWrite(::grpc::ServerContext* /*context*/, const ::sdklt::WriteRequest* /*request*/, ::sdklt::WriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestopenWrite(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_openRead : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_openRead() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_openRead() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status openRead(::grpc::ServerContext* /*context*/, const ::sdklt::ReadRequest* /*request*/, ::sdklt::ReadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestopenRead(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_bcmInit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_bcmInit() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->bcmInit(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_bcmInit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status bcmInit(::grpc::ServerContext* /*context*/, const ::sdklt::InitRequest* /*request*/, ::sdklt::InitState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* bcmInit(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* bcmInit(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_bcmShell : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_bcmShell() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->bcmShell(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_bcmShell() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status bcmShell(::grpc::ServerContext* /*context*/, const ::sdklt::ShellRequest* /*request*/, ::sdklt::ShellState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* bcmShell(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* bcmShell(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_bcmShutdown : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_bcmShutdown() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->bcmShutdown(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_bcmShutdown() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status bcmShutdown(::grpc::ServerContext* /*context*/, const ::sdklt::ShutDownRequest* /*request*/, ::sdklt::ShutDownState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* bcmShutdown(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* bcmShutdown(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_openWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_openWrite() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->openWrite(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_openWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status openWrite(::grpc::ServerContext* /*context*/, const ::sdklt::WriteRequest* /*request*/, ::sdklt::WriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* openWrite(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* openWrite(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_openRead : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_openRead() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->openRead(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_openRead() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status openRead(::grpc::ServerContext* /*context*/, const ::sdklt::ReadRequest* /*request*/, ::sdklt::ReadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* openRead(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* openRead(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_bcmInit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_bcmInit() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::sdklt::InitRequest, ::sdklt::InitState>(std::bind(&WithStreamedUnaryMethod_bcmInit<BaseClass>::StreamedbcmInit, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_bcmInit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status bcmInit(::grpc::ServerContext* /*context*/, const ::sdklt::InitRequest* /*request*/, ::sdklt::InitState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedbcmInit(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sdklt::InitRequest,::sdklt::InitState>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_bcmShell : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_bcmShell() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::sdklt::ShellRequest, ::sdklt::ShellState>(std::bind(&WithStreamedUnaryMethod_bcmShell<BaseClass>::StreamedbcmShell, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_bcmShell() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status bcmShell(::grpc::ServerContext* /*context*/, const ::sdklt::ShellRequest* /*request*/, ::sdklt::ShellState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedbcmShell(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sdklt::ShellRequest,::sdklt::ShellState>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_bcmShutdown : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_bcmShutdown() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::sdklt::ShutDownRequest, ::sdklt::ShutDownState>(std::bind(&WithStreamedUnaryMethod_bcmShutdown<BaseClass>::StreamedbcmShutdown, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_bcmShutdown() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status bcmShutdown(::grpc::ServerContext* /*context*/, const ::sdklt::ShutDownRequest* /*request*/, ::sdklt::ShutDownState* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedbcmShutdown(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sdklt::ShutDownRequest,::sdklt::ShutDownState>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_openWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_openWrite() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::sdklt::WriteRequest, ::sdklt::WriteResponse>(std::bind(&WithStreamedUnaryMethod_openWrite<BaseClass>::StreamedopenWrite, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_openWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status openWrite(::grpc::ServerContext* /*context*/, const ::sdklt::WriteRequest* /*request*/, ::sdklt::WriteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedopenWrite(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sdklt::WriteRequest,::sdklt::WriteResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_openRead : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_openRead() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::sdklt::ReadRequest, ::sdklt::ReadResponse>(std::bind(&WithStreamedUnaryMethod_openRead<BaseClass>::StreamedopenRead, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_openRead() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status openRead(::grpc::ServerContext* /*context*/, const ::sdklt::ReadRequest* /*request*/, ::sdklt::ReadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedopenRead(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sdklt::ReadRequest,::sdklt::ReadResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_bcmInit<WithStreamedUnaryMethod_bcmShell<WithStreamedUnaryMethod_bcmShutdown<WithStreamedUnaryMethod_openWrite<WithStreamedUnaryMethod_openRead<Service > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_bcmInit<WithStreamedUnaryMethod_bcmShell<WithStreamedUnaryMethod_bcmShutdown<WithStreamedUnaryMethod_openWrite<WithStreamedUnaryMethod_openRead<Service > > > > > StreamedService;
};

}  // namespace sdklt


#endif  // GRPC_sdklt_2eproto__INCLUDED
